## 二、构造函数和原型

### 2.1 构造函数和原型

#### 2.1.1 概述

在ES6之前，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和他们的特征。

**创建对象通过以下三种方式：**

1. 对象字面量
2. new object()
3. 自定义构造函数

#### 2.1.2 构造函数

构造函数是一种特殊的函数，总与new一起使用。 可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。

**注意：** 1. 构造函数用于创建某一类对象，其首字母要大写。

2. 构造函数要和new一起使用才有意义

#### 2.1.3 实例成员和静态成员

实例成员：就是构造函数内部通过this添加的成员 实例成员只能通过实例化的对象来访问

静态成员：在构造函数本身上添加的成员 sex就是静态成员 静态成员只能通过构造函数来访问

#### 2.1.4 构造函数的问题

存在浪费内存的问题

#### 2.1.5 构造函数原型 prototype

构造函数通过原型分配的函数是所有对象所共享的

每一个构造函数都有一个prototype属性，指向另一个对象

**我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法**

```、
构造函数.prototype.新增方法 = function(){	功能；	}
```

**一般情况下，我们的公共属性定义到构造函数里面，公共的方法我们放到原型对象身上**

#### 2.1.6 对象原型 _ _proto_ _

对象都会有一个属性__proto__指向构造函数的prototype原型对象

**方法查找的规则：**

首先先看ldh对象身上是否有sing方法，如果有就执行这个对象上的sing 

如果没有sing方法，因为有__proto__ 的存在，就去构造函数原型对象prototype身上去查找sing 方法

#### 2.1.7 constructor 构造函数

对象原型（__proto__）和构造函数（prototype）原型对象里面都有一个属性constructor

**注意：**如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用constructoe指回原来的构造函数

#### 2.1.8 构造函数、实例、原型对象三者之间的关系

![image-20230405182542690](D:\typora\es6笔记\img\二、构造函数、实例、原型对象三者之间的关系.png)

#### 2.1.9 原型链

**注意：**1. 只要是对象就有__proto__ 原型，指向原型对象

2. 我们Star原型对象里面的__proto__原型指向的是Object.prototype
3.  我们Object.prototype 原型对象里面的__proto__原型 指向null![image-20230408085742691](D:\typora\es6笔记\img\2.1.9 原型链.png)

#### 2.1.10 JS的成员查找机制（规则）

按照原型链进行查找。

#### 2.1.11 原型对象this指向

**注意：**1. 在构造函数中，里面的this指向的是对象实例 ldh

2. 原型对象函数里面的this 指向的是 实例对象 ldh

#### 2.1.12 扩展内置对象

可以通过原型对象，对原来的内置对象进行扩展自定义的方法。

### 2.2 继承

在es6并没有给我们提供extends继承。我们可以通过构造函数+原型对象模拟实现继承，称为组合继承。

#### 2.2.1 call()

调用这个函数，并且修改函数运行时的this指向。

```
    func.call(thisArg,arg1,arg2,....)
```

this.Arg： 当前调用函数this的指向对象

arg1,arg2:传递的其他参数

#### 2.2.2 借用构造函数继承父类型属性

核心原理：通过call（）把父类型的this指向子类型的this,这样就可以实现子类继承父类的属性

#### 2.2.3 借用原型对象继承父类型方法

**注意：**不能只通过原型对象等值操作 会被覆盖 成为同一地址（修改了子原型对象，父原型对象也会跟着变化）

```
Son.prototype = new Father();	// 新创建一个实例对象
Son.prototype.constructor = Son;
```

#### 2.2.4 类的本质

es6之前 通过构造函数+ 原型 实现面向对象 编程

es6 通过类 实现面向对象编程

类的本质还是函数 也可以简单的认为 类就是构造函数的另一种写法

**构造函数的特点：**

1. 构造函数有原型对象prototype 
2. 构造函数原型对象prototype 里面有constructor指向构造函数本身
3. 构造函数可以通过原型对象添加方法
4. 构造函数创建的实例对象有__protype__ 原型指向 构造函数的原型对象

**类的特点：**

1. 类有原型对象prototype 
2. 类原型对象prototype 里面有constructor指向构造函数本身
3. 类数可以通过原型对象添加方法
4. 类创建的实例对象有__protype__ 原型指向 构造函数的原型对象

### 2.3 ES5中的新增方法

#### 2.3.1 数组方法

迭代（遍历）方法：foreach()、map()、filter()、some()、every();

##### foreach()

```
array.foreach(function(currentValue,index,arr))
```

currentValue:数组当前项的值

index: 数组当前项的索引

arr:数组对象本身

##### filter()

```
arr.filter(function(currentValue,index,arr))
```

filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组

**注意：直接返回一个新数组** 

currentValue:数组当前项的值

index:数组当前项的索引

arr：数组对象本身

##### some()

```
arr.some(function(currentvalue,index,arr))
```

**注意：**some()方法用于检测数组中的元素是否满足指定条件。换句话说，查找数组中是否有满足条件的元素。

**返回值是布尔值，如果查找到这个元素，就返回true,如果查找不到就返回false**

如果找到第一个满足条件的元素，则终止循环，不在继续查找

currentValue:数组当前项的值

index:数组当前项的索引

arr：数组对象本身

**filter()和some()的区别:**

filter()查找满足条件的元素，返回的是一个数组，而且是把所有满足条件的元素返回回来

some()查找满足条件的元素是否存在，返回的是一个布尔值，如果查找到一个满足条件的元素就终止循环

#### 2.3.2 字符串方法

trim()方法从一个字符串的两端删除空白字符

```
str.trim();
```

trim()方法并不影响源字符串本身，它返回的是一个新的字符串

#### 2.3.3 对象方法

Object.defineProperty()定义对象中新属性或修改原有的属性。

```
Object.defineProperty(obj,prop,descriptor);
```

obj:必需。目标对象

prop:必需。需定义或修改的属性名字

descriptor:必需。目标属性所拥有的特性

**注意:**Object.defineProperty() 第三个参数说明 以对象形式{}书写

value:设置属性的值，默认为undefined

writable:值是否可以重写。true|false 默认为false

enumerable:目标属性是否可以被枚举。true | false 默认为false

configurable:目标属性是否可以被删除或知否可以再次修改特性 true | false 默认为false