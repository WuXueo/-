## 三、函数进阶

### 3.1 函数的定义和调用

#### 3.1.1 函数的定义方法

1. 函数声明方式function关键字（命名函数）

   ```
   function fn(){};
   ```

2. 函数表达式（匿名函数）

   ```
   var fun = function(){};
   ```

3. new Function('参数1','参数2‘，’函数体‘)

   ```
   var f = new Function();
   ```

​	**注意：**Function里面参数必须是字符串格式

​	所有的函数都是Function 的实例(对象)

​	函数也属于对象

![image-20230408174422256](D:\typora\es6笔记\img\3.1.1函数的定义.png)

#### 3.1.2 函数的调用方式

##### 1.普通函数

```
function fn(){};
fn();   /  fn.call();
```

##### 2. 对象的方法

```
var o = {
	sayHi: function(){
	}
}
o.sayHi();
```

##### 3. 构造函数

```
function Star(){}
new Star();
```

##### 4. 绑定事件函数

```
btn.onclick = function(){};			// 点击了按钮就可以调用
```

##### 5. 定时器函数

```
setInterval(function(){},1000);			// 这个函数是定时器自动1秒钟调用一次
```

##### 6. 立即执行函数

```
(function(){}();)					// 立即执行函数是自动调用
```

### 3.2 this

普通函数 this 指向window

对象的方法 this 指向对象

构造函数 this指向 实例对象 原型对象（star.property 指向实例对象）

绑定事件函数 this指向函数调用者

定时器函数 this指向window

立即执行函数 this 指向window

##### 3.2.1 改变函数内部 this 指向

##### bind()、call()、apply()

###### call()

```
fun.call(thisArg,arg1,arg2,....)
```

call()方法**调用一个对象**，简单理解为调用函数的方式，但是它可以**改变函数的this指向**

###### apply()

```
fun.apply(){thisArg,[argsArray]}
```

thisArg：在fun函数运行时指定的this值

argsArray:传递的值，必须包含在**数组**里面

返回值就是函数的返回值，因为他就是**调用函数**

###### bind() **不会调用函数** 但能改变函数内部this指向

```
fun.bind(thisArg,arg1,arg2,...)
```

thisArg:在fun函数运行时指定的this 值

arg1,arg2:传递的其他参数

返回由指定的this值和初始化参数改造的**原函数拷贝**

**如果有的函数我们不需要立即调用，但是又想改变这个函数的this指向此时用bind**

##### 3.2.2 call apply bind 总结

相同点：都可以改变函数内部的this指向

区别点：

1. call和apply会调用函数，并且改变函数内部this指向
2. call和apply传递的参数不一样，call传递参数aru1,aru2...形式，apply必须数组形式[args]
3.  bind 不会调用函数，可以改变函数内部this指向

主要应用场景：

1. call经常做继承
2. apply经常跟数组有关，比如借助数学对象实现数组最大值最小值
3. bind不调用函数，但是还想改变this指向，比如改变定时器内部的this指向

### 3.3 严格模式

严格模式可以应用到**整个脚本**或**个别函数**中。

可以将严格模式分为脚本开启严格模式和为函数开启严格模式。

##### 3.3.1 为脚本开启严格模式

需要在所有语句之前放一个特定语句“use strict”;(或 ’use strict‘;)

```
<script>
	"use strict";			// 开启了严格模式
</script>
```

##### 3.3.2 为某个函数开启严格模式

```
<script>
	function fn(){
	'use strict';		// 只有这个函数会按严格模式执行
	}
</script>
```

##### 3.3.3 严格模式中的变化

###### 变量规定

1. 在正常模式下，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止	，变量必须先用var命令声明，然后再使用。
2. 严禁删除已经声明变量。不可以delete

###### 严格模式下this指向问题

1. 以前在全局作用域函数中的this指向window对象
2.  **严格模式下全局作用域中函数中的this是undefined**
3. 以前的构造函数不加new也可以调用，当普通函数，this指向全局对象
4. 严格模式下，如果构造函数不加new调用，this指向undefined 如果给它赋值会报错
5. new实例化的构造函数指向创建的对象实例
6. 定时器this还是指向window
7. 事件、对象还是指向调用者

###### 函数变化

1. 参数不允许重名
2. 函数必须声明在顶层，不允许在非函数代码块中写函数

### 3.4 高阶函数

高阶函数实对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出

```
<script>
	function fn(callback){
		callback && callback();				// 回调函数
	}
	fn(function(){alert('hi')})
</script>									// 参数是一个函数
```

```
<script>
	function fn(){
		return function(){}
	}
	fn();
</script>									// 函数里面是一个函数
```

### 3.5 闭包

#### 3.5.1 变量作用域

分为全局变量和局部变量。

1. 函数内部可以使用全局变量
1. 函数外部不可以使用局部变量
1. 当函数执行完毕，本作用域的局部变量会销毁、

#### 3.5.2 什么是闭包

闭包指有权访问另一个函数作用域中变量的函数。换句话说，**一个作用域可以访问另一个函数内部的局部变量。**

#### 3.5.3 闭包的主要作用

延伸了变量的作用范围

### 3.6 递归

#### 3.6.1  什么是递归

如果一个函数在内部可以调用其本身，那么这个函数就使递归函数。换句话说，函数内部自己调用自己

必须要加return退出条件. 

#### 3.6.2 浅拷贝和深拷贝

浅拷贝：浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用

**注意：**浅拷贝复杂数据时，只会拷贝它的地址

```
Object.assign(o,obj)			// 将o拷贝给obj
```

深拷贝：深拷贝拷贝多层，每一级别的数据都会拷贝	

深拷贝会重新开辟内存地址
